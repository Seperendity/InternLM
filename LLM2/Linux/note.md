# Linux关卡

## 1. SSH及端口映射

这一小节，我们要了解什么是 **SSH** 、 **为什么使用远程连接** 、如何使用SSH**远程连接**开发机、什么是**端口映射**以及如何进行 **端口映射** 。

### 1.1 什么是SSH？

**SSH**全称Secure Shell，中文翻译为安全外壳，它是一种 **网络安全协议** ，通过加密和认证机制实现安全的访问和文件传输等业务。SSH 协议通过对网络数据进行加密和验证，在不安全的网络环境中提供了安全的网络服务。

SSH 是（C/S架构）由**服务器**和**客户端**组成，为建立安全的 SSH 通道，双方需要先建立 TCP 连接，然后协商使用的版本号和各类算法，并生成相同的**会话密钥**用于后续的对称加密。在完成用户认证后，双方即可建立会话进行数据交互。

那在后面的实践中我们会 **配置SSH密钥** ，配置密钥是为了当我们远程连接开发机时不用重复的输入密码，那 **为什么要进行远程连接呢** ？

远程连接的好处就是，如果你使用的是远程办公，你可以通过SSH远程连接开发机，这样就可以在本地进行开发。而且如果你需要跑一些本地的代码，又没有环境，那么远程连接就非常有必要了。

### 1.2 配置SSH密钥进行SSH远程连接（可选）

但是在我们开发学习的时候，每次远程都输入密码比较麻烦，我们可以设置SSH key来跳过输入密码这一步骤，在ssh命令中我们可以使用**ssh-keygen**命令来生成密钥

> 如果大家计算机的用户名是中文的，InternStudio会识别不了，这种情况就需要用密码来登录SSH，不过不影响使用，大家不用担心。

> SSH密钥是一种安全便捷的登录认证方式，用于在SSH协议中进行身份验证和加密通信。

**ssh-keygen**支持RSA和DSA两种认证密钥。

常用参数包括：

* -t：指定密钥类型，如dsa、ecdsa、ed25519、rsa。
* -b：指定密钥长度。
* -C：添加注释。
* -f：指定保存密钥的文件名。
* -i：读取未加密的ssh-v2兼容的私钥/公钥文件。

这里我们使用RSA算法生成密钥，命令为：

```shell
ssh-keygen -t rsa
```

输入命令后**一路回车**就可以了，这里的密钥默认情况下是生成在 `~/.ssh/`目录下的，`~`表示的是家目录，如果是windows就是 `C:\Users\{your_username}\`。在powerShell中可以使用 `Get-Content`命令查看生成的密钥，如果是linux操作系统可以使用 `cat`命令。然后我们回到开发机平台，在首页点击配置 **SSH Key** ，接着点击 **添加SSH公钥** ，将刚刚生成的密钥复制下来，粘贴到公钥框中，名称会被自动识别到，最后点击立即添加，SSH Key就配置完成了。

### 1.3 端口映射

**端口映射**是一种网络技术，它可以将外网中的任意端口映射到内网中的相应端口，实现内网与外网之间的通信。通过端口映射，可以在外网访问内网中的服务或应用，实现跨越网络的便捷通信。

那么我们使用开发机为什么要进行端口映射呢？

因为在后续的课程中我们会进行模型**web_demo**的部署实践，那在这个过程中，很有可能遇到web ui加载不全的问题。这是因为开发机Web IDE中运行web_demo时，直接访问开发机内 http/https 服务可能会遇到代理问题，外网链接的**ui资源**没有被加载完全。

所以为了解决这个问题，我们需要对运行web_demo的连接进行端口映射，将 **外网链接映射到我们本地主机** ，我们使用本地连接访问，解决这个代理问题。

## 2. linux基础命令

### 2.1 cp and ln

 `cp` **命令在后面课程中会经常用到，它是用来将一个文件或者目录复制到另一个目录下的操作，常用的使用有：**

* 复制文件：`cp 源文件 目标文件`
* 复制目录：`cp -r 源目录 目标目录`

但是如果我们是要使用模型的话，这种操作会占用大量的磁盘空间，所以我们一般使用 `ln`命令，这个就和windows的快捷方式一样。linux中链接分为两种 :  **硬链接** (hard link)与 **软链接** (symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。

所以我们一般使用软连接，它的常用的使用方法如下：

```
ln [参数][源文件或目录][目标文件或目录]
```

参数如下：

* -s：创建软链接（符号链接）也是最常用的；
* -f：强制执行，覆盖已存在的目标文件；
* -i：交互模式，文件存在则提示用户是否覆盖；
* -n：把符号链接视为一般目录；
* -v：显示详细的处理过程。

### 2.2 **find**

`find`命令是Linux系统中一个强大的文件搜索工具，它可以在指定的目录及其子目录中查找符合条件的文件或目录，并执行相应的操作。

以下是 `find`命令的一些常见用法：

1. **按文件名查找** ：使用 `-name`选项按照文件名查找文件。例如，`find /path/to/directory -name "file.txt"`将在指定目录及其子目录中查找名为 `file.txt`的文件。
2. **按文件类型查找** ：使用 `-type`选项按照文件类型查找文件。例如，`find /path/to/directory -type f`将查找指定目录及其子目录中的所有普通文件。
3. **按文件大小查找** ：使用 `-size`选项按照文件大小查找文件。例如，`find /path/to/directory -size +100M`将查找指定目录及其子目录中大于100MB的文件。
4. **按修改时间查找** ：使用 `-mtime`、`-atime`或 `-ctime`选项按照文件的修改时间、访问时间或状态更改时间查找文件。例如，`find /path/to/directory -mtime -7`将查找指定目录及其子目录中在7天内修改过的文件。
5. **按文件权限查找** ：使用 `-perm`选项按照文件权限查找文件。例如，`find /path/to/directory -perm 755`将查找指定目录及其子目录中权限为755的文件。
6. **按用户或组查找** ：使用 `-user`或 `-group`选项按照文件的所有者或所属组查找文件。例如，`find /path/to/directory -user username`将查找指定目录及其子目录中属于用户 `username`的文件。
7. **执行操作** ：使用 `-exec`选项可以对找到的文件执行相应的操作。例如，`find /path/to/directory -name "*.txt" -exec rm {} \;`将删除找到的所有以 `.txt`结尾的文件。

### 2.3 ls

`ls`命令可以用来列出目录的内容以及 **详细信息** 。

常用参数及使用方法如下：

* `-a`：显示所有文件和目录，包括隐藏文件（以 `.`开头的文件或目录）。
* `-l`：以长格式显示详细信息，包括文件权限、所有者、大小、修改时间等。
* `-h`：与 `-l`结合使用，以人类可读的方式显示文件大小（如 `K`、`M`、`G`等）。
* `-R`：递归列出子目录的内容。
* `-t`：按文件修改时间排序显示。

### 2.4 进程管理

**进程管理**命令是进行系统监控和进程管理时的重要工具，常用的进程管理命令有以下几种：

* **ps** ：查看正在运行的进程
* **top** ：动态显示正在运行的进程
* **pstree** ：树状查看正在运行的进程
* **pgrep** ：用于查找进程
* **nice** ：更改进程的优先级
* **jobs** ：显示进程的相关信息
* **bg 和 fg** ：将进程调入后台
* **kill** ：杀死进程

在开发机中还有一条特殊的命令 `nvidia-smi`，它是 NVIDIA 系统管理接口（NVIDIA System Management Interface）的命令行工具，用于监控和管理 NVIDIA GPU 设备。它提供了一种快速查看 GPU 状态、使用情况、温度、内存使用情况、电源使用情况以及运行在 GPU 上的进程等信息的方法。

下面是关于各个命令使用示例：

* `ps`：列出当前系统中的进程。使用不同的选项可以显示不同的进程信息，例如：
  * ```shell
    ps aux  # 显示系统所有进程的详细信息
    ```
* `top`：动态显示系统中进程的状态。它会实时更新进程列表，显示CPU和内存使用率最高的进程。
  * ```shell
    top  # 启动top命令，动态显示进程信息
    ```
* `pstree`：以树状图的形式显示当前运行的进程及其父子关系。
  * ```shell
    pstree  # 显示进程树
    ```
* `pgrep`：查找匹配条件的进程。可以根据进程名、用户等条件查找进程。
  * ```shell
    pgrep -u username  # 查找特定用户的所有进程
    ```
* `nice`：更改进程的优先级。`nice` 值越低，进程优先级越高。
  * ```shell
    nice -n 10 long-running-command  # 以较低优先级运行一个长时间运行的命令
    ```
* `jobs`：显示当前终端会话中的作业列表，包括后台运行的进程。
  * ```shell
    jobs  # 列出当前会话的后台作业
    ```
* `bg` 和 `fg`：`bg` 将挂起的进程放到后台运行，`fg` 将后台进程调回前台运行。
  * ```shell
    bg  # 将最近一个挂起的作业放到后台运行
    fg  # 将后台作业调到前台运行
    ```
* `kill`：发送信号到指定的进程，通常用于杀死进程。
  * ```shell
    kill PID  # 杀死指定的进程ID
    ```
  * 注意，`kill` 命令默认发送 `SIGTERM` 信号，如果进程没有响应，可以使用 `-9`使用 `SIGKILL` 信号强制杀死进程：
  * ```shell
    kill -9 PID  # 强制杀死进程  
    ```

> `SIGTERM`（Signal Termination）信号是Unix和类Unix操作系统中用于请求进程终止的标准信号。当系统或用户想要优雅地关闭一个进程时，通常会发送这个信号。与 `SIGKILL`信号不同，`SIGTERM`信号可以被进程捕获并处理，从而允许进程在退出前进行清理工作。（来源于网络）

以下是 `nvidia-smi` 命令的一些基本命令用法：

* 显示 GPU 状态的摘要信息：
  * ```shell
    nvidia-smi
    ```
* 显示详细的 GPU 状态信息：
  * ```shell
    nvidia-smi -l 1
    ```
  * 这个命令会每1秒更新一次状态信息。
* 显示 GPU 的帮助信息：
  * ```shell
    nvidia-smi -h
    ```
* 列出所有 GPU 并显示它们的 PID 和进程名称：
  * ```shell
    nvidia-smi pmon
    ```
* 强制结束指定的 GPU 进程：
  * ```shell
    nvidia-smi --id=0 --ex_pid=12345
    ```
  * 这会强制结束 GPU ID 为 0 上的 PID 为 12345 的进程。
* 设置 GPU 性能模式：
  * ```shell
    nvidia-smi -pm 1
    nvidia-smi -i 0 -pm 1
    ```
  * 第一个命令会为所有 GPU 设置为性能模式，第二个命令只针对 ID 为 0 的 GPU。
* 重启 GPU：
  * ```shell
    nvidia-smi --id=0 -r
    ```
  * 这会重启 ID 为 0 的 GPU。

### 2.5 工具使用

这里介绍一个工具 `TMUX`，`TMUX` 是一个终端多路复用器。它可以在多个终端之间轻松切换，分离它们（这不会杀死终端，它们继续在后台运行）和将它们重新连接到其他终端中。为什么要介绍这个工具呢？因为在后面进行 `Xtuner`微调模型的时候，时间会很长，使用 `Tmux`可以解决程序被杀死中断的情况，下面介绍一下如何安装并使用。

因为开发机使用的是ubuntu的操作系统，可以使用 `lsb_release -a` 命令查看ubuntu的系统信息：

然后使用 `apt install tmux`命令安装tmux，安装完成以后可以使用 `tmux`命令就可以使用tmux了，如果想退出tmux可以使用“ **Ctrl+d** ”快捷键。

> 开发机仅 /root 路径下的文件是持久化存储的，其他路径下安装的软件重启后都会被重置。

具体的使用方法可以查看：

[https://www.ruanyifeng.com/blog/2019/10/tmux.html](https://www.ruanyifeng.com/blog/2019/10/tmux.html)

## 3. Conda和Shell介绍

### 3.1 删除与导出虚拟环境

如果想要删除某个虚拟环境可以使用 `conda remove --name name --all`，如果只删除虚拟环境中的某个或者某些包可以使用 `conda remove --name name  package_name`

导出虚拟环境对于特定的环境是非常有必要的，因为有些软件包的依赖关系很复杂，如果自己重新进行创建和配置的话很麻烦，如果我们将配置好的环境导出，这样下次使用还原就行了，而且也可以把配置分享给其他人。

```shell
#获得环境中的所有配置
conda env export --name myenv > myenv.yml
#重新还原环境
conda env create -f  myenv.yml
```

### 3.2 conda和pip

这部分我们介绍一些 `conda`和 `pip`的一些区别：

1. conda可以管理非python包，pip只能管理python包。
2. conda可以用来创建虚拟环境，pip不能，需要依赖virtualenv之类的包。
3. conda安装的包是编译好的 **二进制文件** ，安装包文件过程中会自动安装依赖包；pip安装的包是 **wheel或源码** ，装过程中不会去支持python语言之外的依赖项。
4. conda安装的包会统一下载到当前虚拟环境对应的目录下，下载一次多次安装。pip是直接下载到对应环境中。

> **Wheel** 是一种 Python 安装包的格式。
>
> 它是一种预编译的二进制分发格式，类似于 conda 中的已编译二进制文件。
>
> Wheel 格式的主要优点包括：
>
> 1. 安装速度快：因为已经进行了预编译，所以在安装时不需要像源码安装那样进行编译过程，节省了时间。
> 2. 一致性：确保在不同的系统和环境中安装的结果是一致的。
>
> 例如，如果您要安装一个大型的 Python 库，使用 Wheel 格式可以避免在不同的机器上因为编译环境的差异而导致的安装问题。而且，对于那些没有编译环境或者编译能力较弱的系统，Wheel 格式能够让安装过程更加顺畅。
>
